<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <title>Zeus Memory - Tenant Knowledge Graph</title>
    <link rel="icon" href="data:,">
    <!-- Load THREE.js first, then 3d-force-graph will use the global THREE -->
    <script src="//unpkg.com/three@0.160.0/build/three.min.js"></script>
    <script src="//unpkg.com/3d-force-graph@1.73.4/dist/3d-force-graph.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: #0a0a1a;
            overflow: hidden;
        }
        .container {
            display: flex;
            height: 100vh;
            width: 100vw;
        }
        #graph-wrapper {
            flex: 1;
            background: #0a0a1a;
            position: relative;
            overflow: hidden;
        }
        #graph {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }
        #graph canvas {
            width: 100% !important;
            height: 100% !important;
        }
        #sidebar {
            width: 380px;
            min-width: 380px;
            background: #ffffff;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            z-index: 100;
            box-shadow: -2px 0 10px rgba(0,0,0,0.3);
            transition: transform 0.3s ease;
        }
        #sidebar.hidden {
            transform: translateX(100%);
        }
        #sidebar-toggle {
            position: fixed;
            right: 380px;
            top: 50%;
            transform: translateY(-50%);
            width: 24px;
            height: 60px;
            background: #1a365d;
            border: none;
            border-radius: 6px 0 0 6px;
            color: white;
            cursor: pointer;
            z-index: 101;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 14px;
            transition: right 0.3s ease;
        }
        #sidebar-toggle.sidebar-hidden {
            right: 0;
        }
        #sidebar-toggle:hover {
            background: #2d4a7c;
        }
        .header {
            background: linear-gradient(135deg, #1a365d 0%, #2d4a7c 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        .header h1 {
            font-size: 18px;
            font-weight: 600;
            margin-bottom: 5px;
        }
        .header p {
            font-size: 12px;
            opacity: 0.8;
        }

        /* Stats Panel */
        .stats-panel {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
            padding: 12px;
            background: #f8fafc;
            border-bottom: 1px solid #e2e8f0;
        }
        .stat-box {
            background: white;
            border-radius: 6px;
            padding: 10px 8px;
            text-align: center;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        .stat-value {
            font-size: 18px;
            font-weight: 700;
            color: #1a365d;
        }
        .stat-label {
            font-size: 9px;
            color: #718096;
            text-transform: uppercase;
            letter-spacing: 0.3px;
        }

        /* Filters Section in Sidebar */
        .filters-section {
            padding: 15px;
            border-bottom: 1px solid #e2e8f0;
        }
        .filter-section-title {
            font-size: 11px;
            font-weight: 600;
            color: #1a365d;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 10px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        .filter-section-title button {
            font-size: 9px;
            padding: 2px 8px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 3px;
            cursor: pointer;
            color: #666;
        }
        .filter-section-title button:hover {
            background: #f0f0f0;
        }
        .filter-section-title .section-arrow {
            font-size: 10px;
            transition: transform 0.2s;
        }
        .filter-section-title .section-arrow.collapsed {
            transform: rotate(-90deg);
        }
        .filter-chips {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
        }
        .filter-chips.collapsed {
            display: none;
        }
        .filter-chip {
            display: inline-flex;
            align-items: center;
            font-size: 11px;
            color: #333;
            cursor: pointer;
            padding: 4px 10px;
            border-radius: 15px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            transition: all 0.15s;
        }
        .filter-chip:hover {
            background: #e0e0e0;
        }
        .filter-chip.active {
            background: #1a365d;
            color: white;
            border-color: #1a365d;
        }
        .filter-chip .chip-color {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 6px;
        }
        .filter-chip.active .chip-color {
            border: 1px solid rgba(255,255,255,0.5);
        }

        /* Info Panel */
        #info-panel {
            padding: 15px;
            flex: 1;
            overflow-y: auto;
        }
        .info-placeholder {
            color: #666;
            text-align: center;
            padding: 30px 15px;
        }
        .info-placeholder p {
            margin-bottom: 8px;
            font-size: 12px;
        }
        .node-info {
            display: none;
        }
        .node-info.active {
            display: block;
        }
        .node-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 15px;
            padding-bottom: 15px;
            border-bottom: 2px solid #e0e0e0;
        }
        .node-color-dot {
            width: 16px;
            height: 16px;
            border-radius: 4px;
            flex-shrink: 0;
        }
        .node-header-text {
            flex: 1;
        }
        .node-title {
            font-size: 15px;
            font-weight: 600;
            color: #1a365d;
            margin-bottom: 4px;
        }
        .node-tier {
            display: inline-block;
            padding: 3px 10px;
            border-radius: 12px;
            font-size: 10px;
            font-weight: 600;
            color: white;
        }
        .tier-hub { background: #1a365d; }
        .tier-tenant { background: #3182ce; }
        .tier-source { background: #38a169; }
        .tier-memory { background: #805ad5; }
        .node-description {
            color: #444;
            line-height: 1.6;
            margin-bottom: 15px;
            font-size: 12px;
            background: #f8f9fa;
            padding: 12px;
            border-radius: 6px;
            max-height: 150px;
            overflow-y: auto;
        }
        .node-meta {
            font-size: 11px;
            color: #666;
            margin-bottom: 15px;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 6px;
        }
        .node-meta span {
            display: block;
            margin-bottom: 4px;
        }
        .node-meta .label {
            color: #888;
            font-weight: 500;
        }
        .connections-header {
            font-size: 11px;
            font-weight: 600;
            color: #718096;
            margin-bottom: 10px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        .connection-list {
            list-style: none;
        }
        .connection-item {
            padding: 10px 12px;
            margin-bottom: 6px;
            background: #f8f9fa;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.15s ease;
            border-left: 3px solid #e0e0e0;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .connection-item:hover {
            background: #e8f4fd;
            border-left-color: #3182ce;
            transform: translateX(3px);
        }
        .connection-item.semantic {
            border-left-color: #805ad5;
            background: #faf5ff;
        }
        .connection-item .conn-color {
            width: 10px;
            height: 10px;
            border-radius: 3px;
            flex-shrink: 0;
        }
        .connection-item .conn-info {
            flex: 1;
            min-width: 0;
        }
        .connection-item .name {
            font-weight: 500;
            color: #1a365d;
            font-size: 12px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .connection-item .relation {
            font-size: 10px;
            color: #718096;
        }

        /* Toolbar */
        #toolbar {
            position: absolute;
            top: 12px;
            left: 12px;
            background: rgba(255, 255, 255, 0.95);
            padding: 8px 12px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 10000;
            display: flex;
            align-items: center;
            gap: 10px;
        }
        .toolbar-section {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .toolbar-divider {
            width: 1px;
            height: 24px;
            background: #ddd;
        }
        .view-btn {
            padding: 6px 14px;
            border: 1px solid #1a365d;
            background: white;
            color: #1a365d;
            font-weight: 600;
            font-size: 11px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.2s;
        }
        .view-btn.active {
            background: #1a365d;
            color: white;
        }
        .view-btn:hover:not(.active) {
            background: #e8f4fd;
        }
        .layout-select {
            font-size: 11px;
            padding: 5px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: white;
            cursor: pointer;
        }
        .shape-chip {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            width: 26px;
            height: 26px;
            font-size: 14px;
            cursor: pointer;
            border-radius: 4px;
            background: #f0f0f0;
            border: 1px solid #ddd;
            transition: all 0.15s;
        }
        .shape-chip:hover {
            background: #e0e0e0;
        }
        .shape-chip.active {
            background: #1a365d;
            color: white;
            border-color: #1a365d;
        }

        /* Effects toggle */
        .effects-toggle {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        .toggle-switch {
            position: relative;
            width: 28px;
            height: 16px;
            background: #ccc;
            border-radius: 8px;
            cursor: pointer;
            transition: background 0.2s;
        }
        .toggle-switch.active {
            background: #3182ce;
        }
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 2px;
            left: 2px;
            width: 12px;
            height: 12px;
            background: white;
            border-radius: 50%;
            transition: left 0.2s;
        }
        .toggle-switch.active::after {
            left: 14px;
        }
        .toggle-label {
            font-size: 9px;
            color: #666;
        }

        /* Search bar */
        .search-container {
            display: flex;
            align-items: center;
            gap: 4px;
        }
        #search-input {
            font-size: 11px;
            padding: 4px 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
            width: 150px;
            background: white;
        }
        #search-input:focus {
            outline: none;
            border-color: #3182ce;
            box-shadow: 0 0 0 2px rgba(49, 130, 206, 0.2);
        }
        .search-results {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-radius: 4px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 10001;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            display: none;
        }
        .search-results.active {
            display: block;
        }
        .search-result-item {
            padding: 8px 12px;
            cursor: pointer;
            border-bottom: 1px solid #eee;
            font-size: 11px;
        }
        .search-result-item:hover {
            background: #f0f7ff;
        }
        .search-result-item:last-child {
            border-bottom: none;
        }
        .search-result-item .name {
            font-weight: 500;
            color: #1a365d;
        }
        .search-result-item .type {
            font-size: 10px;
            color: #666;
        }

        /* Time slider */
        .time-slider-container {
            display: flex;
            align-items: center;
            gap: 6px;
        }
        #time-slider {
            width: 120px;
            height: 4px;
            -webkit-appearance: none;
            background: #ddd;
            border-radius: 2px;
            cursor: pointer;
        }
        #time-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 14px;
            height: 14px;
            background: #3182ce;
            border-radius: 50%;
            cursor: pointer;
        }
        .time-display {
            font-size: 10px;
            color: #666;
            min-width: 80px;
        }
        .play-btn {
            font-size: 12px;
            padding: 2px 8px;
            border: 1px solid #ccc;
            background: white;
            border-radius: 3px;
            cursor: pointer;
        }
        .play-btn:hover {
            background: #f0f0f0;
        }
        .play-btn.playing {
            background: #3182ce;
            color: white;
            border-color: #3182ce;
        }

        /* VR button */
        .vr-btn {
            padding: 4px 10px;
            border: 1px solid #805ad5;
            background: white;
            color: #805ad5;
            font-weight: 600;
            font-size: 10px;
            cursor: pointer;
            border-radius: 4px;
            transition: all 0.15s;
        }
        .vr-btn:hover:not(:disabled) {
            background: #805ad5;
            color: white;
        }
        .vr-btn:disabled {
            opacity: 0.4;
            cursor: default;
        }

        /* Multi-select indicator */
        .selection-count {
            font-size: 10px;
            color: #805ad5;
            font-weight: 600;
            padding: 2px 8px;
            background: rgba(128, 90, 213, 0.1);
            border-radius: 10px;
            display: none;
        }
        .selection-count.active {
            display: inline-block;
        }

        /* Stats display */
        .stats-display {
            font-size: 9px;
            color: #666;
            padding: 2px 6px;
            background: rgba(255,255,255,0.9);
            border-radius: 3px;
        }

        /* Extended toolbar */
        .toolbar-extended {
            position: absolute;
            top: 50px;
            left: 12px;
            background: rgba(255, 255, 255, 0.95);
            padding: 6px 10px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 9999;
            display: flex;
            align-items: center;
            gap: 8px;
        }
        .toolbar-extended.hidden {
            display: none;
        }

        /* Heat map legend */
        .heatmap-legend {
            display: none;
            position: absolute;
            bottom: 60px;
            left: 12px;
            background: rgba(255,255,255,0.95);
            padding: 10px;
            border-radius: 6px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        .heatmap-legend.active {
            display: block;
        }
        .heatmap-gradient {
            width: 150px;
            height: 12px;
            background: linear-gradient(to right, #3182ce, #38a169, #ecc94b, #e53e3e);
            border-radius: 2px;
            margin-bottom: 4px;
        }
        .heatmap-labels {
            display: flex;
            justify-content: space-between;
            font-size: 9px;
            color: #666;
        }

        /* Legend */
        .legend {
            position: absolute;
            bottom: 12px;
            left: 12px;
            background: rgba(255, 255, 255, 0.95);
            padding: 12px 16px;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
            z-index: 1000;
        }
        .legend-title {
            font-size: 10px;
            font-weight: 600;
            color: #718096;
            text-transform: uppercase;
            margin-bottom: 8px;
        }
        .legend-items {
            display: flex;
            gap: 14px;
            flex-wrap: wrap;
        }
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 11px;
            color: #4a5568;
        }
        .legend-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
        }
        .legend-line {
            width: 20px;
            height: 2px;
            border-radius: 1px;
        }

        /* Loading */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(10, 10, 26, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 5000;
        }
        .loading-overlay.hidden {
            display: none;
        }
        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(255,255,255,0.1);
            border-top-color: #3182ce;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        .loading-text {
            color: #a0aec0;
            margin-top: 16px;
            font-size: 14px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .footer {
            padding: 12px 15px;
            background: #f8fafc;
            border-top: 1px solid #e2e8f0;
            text-align: center;
            font-size: 10px;
            color: #718096;
        }
    </style>
</head>
<body>
    <div class="container">
        <div id="graph-wrapper">
            <div id="graph"></div>
            <div id="toolbar">
                <div class="toolbar-section">
                    <button class="view-btn active" id="btn-3d" onclick="setView('3d')">3D</button>
                    <button class="view-btn" id="btn-2d" onclick="setView('2d')">2D</button>
                </div>
                <div class="toolbar-divider"></div>
                <div class="toolbar-section">
                    <span style="font-size:10px;color:#666;margin-right:4px;">Layout:</span>
                    <select id="layout-select" class="layout-select" onchange="changeLayout()">
                        <option value="force">Force-Directed</option>
                        <option value="layered">Layered 3D</option>
                        <option value="spherical">Spherical</option>
                        <option value="cylinder">Cylinder Rings</option>
                    </select>
                </div>
                <div class="toolbar-divider"></div>
                <div class="toolbar-section">
                    <span style="font-size:10px;color:#666;margin-right:4px;">Shape:</span>
                    <span class="shape-chip active" data-shape="sphere" onclick="setNodeGeometry('sphere')">&#9679;</span>
                    <span class="shape-chip" data-shape="cube" onclick="setNodeGeometry('cube')">&#9632;</span>
                    <span class="shape-chip" data-shape="diamond" onclick="setNodeGeometry('diamond')">&#9670;</span>
                    <span class="shape-chip" data-shape="ring" onclick="setNodeGeometry('ring')">&#9675;</span>
                </div>
                <div class="toolbar-divider"></div>
                <div class="toolbar-section">
                    <button class="view-btn" onclick="resetCamera()">Reset</button>
                    <button class="view-btn" onclick="zoomToFit()">Fit</button>
                </div>
            </div>
            <!-- Extended Toolbar with effects toggles, search, etc. -->
            <div id="toolbar-extended" class="toolbar-extended">
                <!-- Search -->
                <div class="toolbar-section search-container" style="position: relative;">
                    <input type="text" id="search-input" placeholder="Search nodes..." onkeyup="handleSearch(event)" onfocus="showSearchResults()" onblur="hideSearchResults()">
                    <div id="search-results" class="search-results"></div>
                </div>
                <div class="toolbar-divider"></div>
                <!-- Effects toggles -->
                <div class="toolbar-section effects-toggle">
                    <span class="toggle-label">Glow</span>
                    <div id="glow-toggle" class="toggle-switch" onclick="toggleGlow()"></div>
                </div>
                <div class="toolbar-section effects-toggle">
                    <span class="toggle-label">Particles</span>
                    <div id="particles-toggle" class="toggle-switch active" onclick="toggleParticles()"></div>
                </div>
                <div class="toolbar-section effects-toggle">
                    <span class="toggle-label">Labels</span>
                    <div id="labels-toggle" class="toggle-switch active" onclick="toggleLabels()"></div>
                </div>
                <div class="toolbar-section effects-toggle">
                    <span class="toggle-label">Light</span>
                    <div id="theme-toggle" class="toggle-switch" onclick="toggleTheme()"></div>
                </div>
                <div class="toolbar-section effects-toggle">
                    <span class="toggle-label">Rings</span>
                    <div id="rings-toggle" class="toggle-switch active" onclick="toggleRings()"></div>
                </div>
                <div class="toolbar-section effects-toggle">
                    <span class="toggle-label">Logos</span>
                    <div id="logo-labels-toggle" class="toggle-switch active" onclick="toggleLogoLabels()"></div>
                </div>
                <div class="toolbar-divider"></div>
                <!-- Multi-select indicator -->
                <span id="selection-count" class="selection-count">0 selected</span>
                <!-- VR button -->
                <button id="vr-btn" class="vr-btn" onclick="enterVR()" disabled>VR</button>
                <!-- Stats -->
                <span id="stats-display" class="stats-display"></span>
            </div>
            <!-- Time slider -->
            <div id="time-toolbar" class="toolbar-extended" style="top: 90px; display: none;">
                <div class="toolbar-section time-slider-container">
                    <span style="font-size:10px;color:#666;">Time:</span>
                    <button id="play-btn" class="play-btn" onclick="toggleTimePlay()">&#9654;</button>
                    <input type="range" id="time-slider" min="0" max="100" value="100" oninput="updateTimeSlider()">
                    <span id="time-display" class="time-display">All time</span>
                </div>
            </div>
            <!-- Heat map legend -->
            <div id="heatmap-legend" class="heatmap-legend">
                <div class="heatmap-gradient"></div>
                <div class="heatmap-labels">
                    <span>Low</span>
                    <span>High</span>
                </div>
            </div>
            <div class="legend">
                <div class="legend-title">Node Types</div>
                <div class="legend-items">
                    <div class="legend-item"><div class="legend-dot" style="background:#1a365d"></div>Hub</div>
                    <div class="legend-item"><div class="legend-dot" style="background:#3182ce"></div>Tenant</div>
                    <div class="legend-item"><div class="legend-dot" style="background:#38a169"></div>Source</div>
                    <div class="legend-item"><div class="legend-dot" style="background:#805ad5"></div>Memory</div>
                    <div class="legend-item"><div class="legend-line" style="background:rgba(255,255,255,0.4)"></div>Hierarchy</div>
                    <div class="legend-item"><div class="legend-line" style="background:#805ad5"></div>Semantic</div>
                </div>
            </div>
            <div class="loading-overlay" id="loading">
                <div class="loading-spinner"></div>
                <div class="loading-text">Loading Zeus Memory graph...</div>
            </div>
        </div>
        <button id="sidebar-toggle" onclick="toggleSidebar()">&#9664;</button>
        <div id="sidebar">
            <div class="header">
                <h1>Zeus Memory</h1>
                <p>Tenant Knowledge Graph with Semantic Relationships</p>
            </div>
            <div class="stats-panel">
                <div class="stat-box">
                    <div class="stat-value" id="total-memories">-</div>
                    <div class="stat-label">Memories</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="total-tenants">-</div>
                    <div class="stat-label">Tenants</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="total-sources">-</div>
                    <div class="stat-label">Sources</div>
                </div>
                <div class="stat-box">
                    <div class="stat-value" id="total-semantic">-</div>
                    <div class="stat-label">Semantic</div>
                </div>
            </div>

            <!-- Collapsible Filters Sections -->
            <div class="filters-section">
                <div class="filter-section-title" onclick="toggleFilterSection('node-filters')">
                    Node Types
                    <span class="section-arrow" id="arrow-node-filters">&#9660;</span>
                    <button onclick="event.stopPropagation(); toggleAllNodes()">Toggle All</button>
                </div>
                <div class="filter-chips" id="node-filters">
                    <span class="filter-chip active" data-group="hub"><span class="chip-color" style="background:#1a365d"></span>Hub</span>
                    <span class="filter-chip active" data-group="tenant"><span class="chip-color" style="background:#3182ce"></span>Tenants</span>
                    <span class="filter-chip active" data-group="source"><span class="chip-color" style="background:#38a169"></span>Sources</span>
                    <span class="filter-chip active" data-group="memory"><span class="chip-color" style="background:#805ad5"></span>Memories</span>
                </div>
            </div>

            <div class="filters-section">
                <div class="filter-section-title" onclick="toggleFilterSection('source-filters')">
                    Source Categories
                    <span class="section-arrow" id="arrow-source-filters">&#9660;</span>
                    <button onclick="event.stopPropagation(); toggleAllSources()">Toggle All</button>
                </div>
                <div class="filter-chips" id="source-filters">
                    <span class="filter-chip active" data-source="email"><span class="chip-color" style="background:#63b3ed"></span>Email</span>
                    <span class="filter-chip active" data-source="slack"><span class="chip-color" style="background:#f6ad55"></span>Slack</span>
                    <span class="filter-chip active" data-source="rss"><span class="chip-color" style="background:#9ae6b4"></span>RSS</span>
                    <span class="filter-chip active" data-source="research"><span class="chip-color" style="background:#fbd38d"></span>Research</span>
                    <span class="filter-chip active" data-source="api"><span class="chip-color" style="background:#fc8181"></span>API</span>
                    <span class="filter-chip active" data-source="documents"><span class="chip-color" style="background:#b794f4"></span>Docs</span>
                    <span class="filter-chip active" data-source="other"><span class="chip-color" style="background:#a0aec0"></span>Other</span>
                </div>
            </div>

            <div class="filters-section">
                <div class="filter-section-title" onclick="toggleFilterSection('edge-filters')">
                    Edge Types
                    <span class="section-arrow" id="arrow-edge-filters">&#9660;</span>
                    <button onclick="event.stopPropagation(); toggleSemanticLinks()">Toggle Semantic</button>
                </div>
                <div class="filter-chips" id="edge-filters">
                    <span class="filter-chip active" data-edge="hierarchy"><span class="chip-color" style="background:rgba(255,255,255,0.4)"></span>Hierarchy</span>
                    <span class="filter-chip active" data-edge="semantic"><span class="chip-color" style="background:#805ad5"></span>Semantic Links</span>
                </div>
            </div>

            <div id="info-panel">
                <div class="info-placeholder" id="placeholder">
                    <p><strong>Click a node</strong> to explore</p>
                    <p>Drag to rotate &bull; Scroll to zoom &bull; Right-drag to pan</p>
                    <p style="margin-top:10px;font-size:10px;color:#888;">
                        <strong>Shift+Click</strong> to multi-select nodes<br>
                        <strong>Search</strong> nodes via the toolbar above
                    </p>
                    <p style="margin-top:15px;font-size:10px;color:#888;">
                        <strong>Hierarchy:</strong> Hub &rarr; Tenants &rarr; Sources &rarr; Memories<br>
                        <strong>Semantic Links:</strong> Cross-source relationships based on embedding similarity
                    </p>
                </div>
                <div class="node-info" id="node-info">
                    <div class="node-header">
                        <div class="node-color-dot" id="node-color"></div>
                        <div class="node-header-text">
                            <div class="node-title" id="node-title">-</div>
                            <span class="node-tier" id="node-tier">-</span>
                        </div>
                    </div>
                    <div class="node-description" id="node-description">-</div>
                    <div class="node-meta" id="node-meta"></div>
                    <div id="connections-section">
                        <div class="connections-header">Connections</div>
                        <ul class="connection-list" id="connections-list"></ul>
                    </div>
                </div>
            </div>
            <div class="footer">Powered by Zeus Memory | ALDC</div>
        </div>
    </div>

    <script>
        // Graph state
        let graph;
        let graphData = { nodes: [], links: [] };
        let selectedNode = null;
        let sidebarVisible = true;

        // Filter state
        const activeNodeTypes = new Set(['hub', 'tenant', 'source', 'memory']);
        const activeSourceCategories = new Set(['email', 'slack', 'rss', 'research', 'api', 'documents', 'other']);
        const activeEdgeTypes = new Set(['hierarchy', 'semantic']);

        // Node lookup
        const nodeMap = {};

        // Effects state
        let glowEnabled = false;
        let particlesEnabled = true;
        let labelsEnabled = true;
        let currentTheme = 'dark';
        let ringsEnabled = true;
        let logoLabelsEnabled = true;
        let timeSliderValue = 100;
        let timePlayInterval = null;

        // Multi-select state
        const multiSelectedNodes = new Set();

        // Collapsible sidebar sections
        function toggleFilterSection(sectionId) {
            const chips = document.getElementById(sectionId);
            const arrow = document.getElementById('arrow-' + sectionId);
            chips.classList.toggle('collapsed');
            if (arrow) arrow.classList.toggle('collapsed');
        }

        function toggleSidebar() {
            const sidebar = document.getElementById('sidebar');
            const toggle = document.getElementById('sidebar-toggle');
            sidebarVisible = !sidebarVisible;
            sidebar.classList.toggle('hidden', !sidebarVisible);
            toggle.classList.toggle('sidebar-hidden', !sidebarVisible);
            toggle.innerHTML = sidebarVisible ? '&#9664;' : '&#9654;';
        }

        function setView(mode) {
            document.getElementById('btn-3d').classList.toggle('active', mode === '3d');
            document.getElementById('btn-2d').classList.toggle('active', mode === '2d');

            if (mode === '2d') {
                graph.cameraPosition({ x: 0, y: 0, z: 800 }, { x: 0, y: 0, z: 0 }, 1000);
                graph.enableNodeDrag(true);
            } else {
                graph.cameraPosition({ x: 0, y: 200, z: 500 }, { x: 0, y: 0, z: 0 }, 1000);
            }
        }

        function resetCamera() {
            graph.cameraPosition({ x: 0, y: 200, z: 500 }, { x: 0, y: 0, z: 0 }, 1500);
        }

        function zoomToFit() {
            graph.zoomToFit(500, 50);
        }

        // Layout state
        let currentLayout = 'force';
        let currentGeometry = 'sphere';
        let tierPlatforms = [];

        function changeLayout() {
            currentLayout = document.getElementById('layout-select').value;

            // Clear tier platforms when switching away from cylinder
            if (currentLayout !== 'cylinder') {
                clearTierPlatforms();
            }

            switch(currentLayout) {
                case 'force':
                    applyForceLayout();
                    break;
                case 'layered':
                    applyLayeredLayout();
                    break;
                case 'spherical':
                    applySphericalLayout();
                    break;
                case 'cylinder':
                    applyCylinderLayout();
                    break;
            }
        }

        function applyForceLayout() {
            // Reset to force-directed (clear fixed positions)
            const nodes = graph.graphData().nodes;
            if (nodes.length === 0) return;
            nodes.forEach(node => {
                node.fx = undefined;
                node.fy = undefined;
                node.fz = undefined;
            });
            graph.d3ReheatSimulation();
        }

        function applyLayeredLayout() {
            // Z-axis represents tier/hierarchy
            const nodes = graph.graphData().nodes;
            if (nodes.length === 0) return;

            const tierSpacing = 120;
            const tierCounts = {};

            nodes.forEach(node => {
                const tier = node.tier || 0;
                if (!tierCounts[tier]) tierCounts[tier] = { count: 0, total: 0 };
                tierCounts[tier].total++;
            });

            nodes.forEach(node => {
                const tier = node.tier || 0;
                const angle = (tierCounts[tier].count / tierCounts[tier].total) * Math.PI * 2;
                const radius = 30 + tier * 100;

                node.fx = Math.cos(angle) * radius;
                node.fy = Math.sin(angle) * radius;
                node.fz = tier * tierSpacing;

                tierCounts[tier].count++;
            });

            graph.d3ReheatSimulation();
            setTimeout(() => graph.zoomToFit(500), 100);
        }

        function applySphericalLayout() {
            // Nodes on sphere surface, grouped by category
            const nodes = graph.graphData().nodes;
            if (nodes.length === 0) return;

            const radius = 250;
            const groups = {};

            nodes.forEach(node => {
                const group = node.group || 'default';
                if (!groups[group]) groups[group] = [];
                groups[group].push(node);
            });

            const groupKeys = Object.keys(groups);
            groupKeys.forEach((group, gi) => {
                const phi = (gi / groupKeys.length) * Math.PI * 2;

                groups[group].forEach((node, ni) => {
                    const theta = (ni / groups[group].length) * Math.PI - Math.PI / 2;
                    const r = radius + (node.tier || 0) * 50;

                    node.fx = r * Math.cos(theta) * Math.cos(phi);
                    node.fy = r * Math.sin(theta);
                    node.fz = r * Math.cos(theta) * Math.sin(phi);
                });
            });

            graph.d3ReheatSimulation();
            setTimeout(() => graph.zoomToFit(500), 100);
        }

        function clearTierPlatforms() {
            const scene = graph.scene();
            tierPlatforms.forEach(mesh => {
                scene.remove(mesh);
                if (mesh.geometry) mesh.geometry.dispose();
                if (mesh.material) mesh.material.dispose();
            });
            tierPlatforms = [];
        }

        function applyCylinderLayout() {
            // Y-axis = tier/hierarchy, circumference = category/group
            const nodes = graph.graphData().nodes;
            if (nodes.length === 0) return;

            clearTierPlatforms();

            const scene = graph.scene();
            const baseRadius = 150;
            const tierSpacing = 100;
            const maxTier = Math.max(...nodes.map(n => n.tier || 0));

            // Create ring platforms for each tier (if rings enabled)
            if (ringsEnabled) {
                for (let tier = 0; tier <= maxTier; tier++) {
                    const radius = baseRadius + tier * 50;
                    const ringGeometry = new THREE.TorusGeometry(radius, 2, 8, 64);
                    const ringMaterial = new THREE.MeshBasicMaterial({
                        color: tier === 0 ? 0x1a365d : (tier === 1 ? 0x3182ce : (tier === 2 ? 0x38a169 : 0x805ad5)),
                        transparent: true,
                        opacity: 0.3
                    });
                    const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                    ring.rotation.x = Math.PI / 2;
                    ring.position.y = tier * tierSpacing;
                    scene.add(ring);
                    tierPlatforms.push(ring);
                }
            }

            // Group nodes by tier
            const tierGroups = {};
            nodes.forEach(node => {
                const tier = node.tier || 0;
                if (!tierGroups[tier]) tierGroups[tier] = [];
                tierGroups[tier].push(node);
            });

            // Position nodes on cylinder
            Object.entries(tierGroups).forEach(([tier, tierNodes]) => {
                const t = parseInt(tier);
                const radius = baseRadius + t * 50;
                const y = t * tierSpacing;

                // Group by source/category within tier for clustering
                const subgroups = {};
                tierNodes.forEach(node => {
                    const sg = node.group || 'default';
                    if (!subgroups[sg]) subgroups[sg] = [];
                    subgroups[sg].push(node);
                });

                const sgKeys = Object.keys(subgroups);
                let angleOffset = 0;

                sgKeys.forEach((sg, sgi) => {
                    const sgNodes = subgroups[sg];
                    const arcSpan = (sgNodes.length / tierNodes.length) * Math.PI * 2;

                    sgNodes.forEach((node, ni) => {
                        const angle = angleOffset + (ni / sgNodes.length) * arcSpan;
                        node.fx = Math.cos(angle) * radius;
                        node.fy = y;
                        node.fz = Math.sin(angle) * radius;
                    });

                    angleOffset += arcSpan;
                });
            });

            graph.d3ReheatSimulation();
            setTimeout(() => {
                graph.cameraPosition({ x: 300, y: 200, z: 300 }, { x: 0, y: tierSpacing * maxTier / 2, z: 0 }, 1000);
            }, 100);
        }

        function setNodeGeometry(shape) {
            currentGeometry = shape;
            document.querySelectorAll('.shape-chip').forEach(c => c.classList.remove('active'));
            document.querySelector(`.shape-chip[data-shape="${shape}"]`).classList.add('active');
            // Re-render nodes with new geometry
            rebuildNodeRendering();
        }

        // --- Glow effect ---
        function toggleGlow() {
            glowEnabled = !glowEnabled;
            document.getElementById('glow-toggle').classList.toggle('active', glowEnabled);
            rebuildNodeRendering();
        }

        function createGlowTexture(color) {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');

            const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, color);
            gradient.addColorStop(0.2, color);
            gradient.addColorStop(0.4, hexToRgba(color, 0.5));
            gradient.addColorStop(0.7, hexToRgba(color, 0.2));
            gradient.addColorStop(1, 'rgba(0,0,0,0)');

            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);

            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }

        function hexToRgba(hex, alpha) {
            let r = 0, g = 0, b = 0;
            if (hex && hex.length === 4) {
                r = parseInt(hex[1] + hex[1], 16);
                g = parseInt(hex[2] + hex[2], 16);
                b = parseInt(hex[3] + hex[3], 16);
            } else if (hex && hex.length === 7) {
                r = parseInt(hex.slice(1, 3), 16);
                g = parseInt(hex.slice(3, 5), 16);
                b = parseInt(hex.slice(5, 7), 16);
            }
            return `rgba(${r},${g},${b},${alpha})`;
        }

        // --- Edge particles ---
        function toggleParticles() {
            particlesEnabled = !particlesEnabled;
            document.getElementById('particles-toggle').classList.toggle('active', particlesEnabled);
            applyParticles();
        }

        function applyParticles() {
            if (particlesEnabled) {
                graph.linkDirectionalParticles(link => link.type === 'semantic' ? 4 : 2)
                    .linkDirectionalParticleSpeed(0.006)
                    .linkDirectionalParticleWidth(link => link.type === 'semantic' ? 3 : 1.5)
                    .linkDirectionalParticleColor(link => link.type === 'semantic' ? '#b794f4' : '#63b3ed');
            } else {
                graph.linkDirectionalParticles(0);
            }
        }

        // --- Labels toggle ---
        function toggleLabels() {
            labelsEnabled = !labelsEnabled;
            document.getElementById('labels-toggle').classList.toggle('active', labelsEnabled);
            rebuildNodeRendering();
        }

        // --- Logo + Label node rendering ---
        function toggleLogoLabels() {
            logoLabelsEnabled = !logoLabelsEnabled;
            const toggle = document.getElementById('logo-labels-toggle');
            if (toggle) toggle.classList.toggle('active', logoLabelsEnabled);
            rebuildNodeRendering();
        }

        function createLogoLabelSprite(name, color, nodeSize, nodeType, logoUrl) {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = 256;
            canvas.height = 320;

            // Start with fully transparent background
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw label below
            ctx.font = 'bold 28px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'top';

            // Truncate text if too long
            let displayText = name;
            while (ctx.measureText(displayText).width > 240 && displayText.length > 3) {
                displayText = displayText.slice(0, -4) + '...';
            }
            ctx.fillText(displayText, 128, 240);

            // Draw colored circle background
            ctx.beginPath();
            ctx.arc(128, 120, 96, 0, Math.PI * 2);
            ctx.fillStyle = color || '#718096';
            ctx.fill();

            // Draw type icon/initials
            const initials = name.split(/[\s\-\/]+/).filter(w => w.length > 0).slice(0, 2).map(w => w[0]).join('').toUpperCase();
            ctx.font = 'bold 64px -apple-system, BlinkMacSystemFont, sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(initials, 128, 120);

            // Small type badge at bottom of circle
            if (nodeType) {
                const badgeColors = { hub: '#1a365d', tenant: '#3182ce', source: '#38a169', memory: '#805ad5' };
                const badgeColor = badgeColors[nodeType] || '#718096';
                ctx.beginPath();
                ctx.arc(128, 200, 24, 0, Math.PI * 2);
                ctx.fillStyle = badgeColor;
                ctx.fill();
                ctx.strokeStyle = 'rgba(255,255,255,0.8)';
                ctx.lineWidth = 2;
                ctx.stroke();

                const typeLabel = nodeType.charAt(0).toUpperCase();
                ctx.font = 'bold 22px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = '#ffffff';
                ctx.fillText(typeLabel, 128, 201);
            }

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMat = new THREE.SpriteMaterial({
                map: texture,
                transparent: true,
                depthTest: false,
                depthWrite: false
            });
            const sprite = new THREE.Sprite(spriteMat);
            sprite.scale.set(nodeSize * 3, nodeSize * 3.75, 1);
            sprite.renderOrder = 1000;

            // Load logo image if URL provided
            const finalLogoUrl = logoUrl || null;
            if (finalLogoUrl) {
                const img = new Image();
                img.crossOrigin = 'anonymous';

                // Use weserv.nl image proxy for CORS support (skip for data URIs)
                let proxiedUrl = finalLogoUrl;
                if (!finalLogoUrl.startsWith('data:')) {
                    try {
                        const urlObj = new URL(finalLogoUrl);
                        const urlWithoutProtocol = urlObj.host + urlObj.pathname + urlObj.search;
                        proxiedUrl = 'https://images.weserv.nl/?url=' + encodeURIComponent(urlWithoutProtocol);
                    } catch (e) {
                        console.warn('Invalid logo URL:', finalLogoUrl);
                    }
                }

                img.onload = () => {
                    // Clear the circle area and redraw with logo
                    ctx.clearRect(0, 0, 256, 220);

                    // Draw logo clipped to circle
                    ctx.save();
                    ctx.beginPath();
                    ctx.arc(128, 120, 96, 0, Math.PI * 2);
                    ctx.clip();
                    ctx.drawImage(img, 32, 24, 192, 192);
                    ctx.restore();

                    texture.needsUpdate = true;
                };
                img.onerror = (e) => {
                    console.warn('Failed to load logo for', name, ':', proxiedUrl);
                    texture.needsUpdate = true;
                };
                img.src = proxiedUrl;
            } else {
                texture.needsUpdate = true;
            }

            return sprite;
        }

        // --- Theme toggle (light/dark mode) ---
        function toggleTheme() {
            currentTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.getElementById('theme-toggle').classList.toggle('active', currentTheme === 'light');
            applyTheme();
        }

        function applyTheme() {
            const body = document.body;
            const graphWrapper = document.getElementById('graph-wrapper');

            if (currentTheme === 'light') {
                body.style.background = '#f5f7fa';
                graphWrapper.style.background = '#f0f4f8';
                if (graph && graph.backgroundColor) {
                    graph.backgroundColor('#f0f4f8');
                }
            } else {
                body.style.background = '#0a0a1a';
                graphWrapper.style.background = '#0a0a1a';
                if (graph && graph.backgroundColor) {
                    graph.backgroundColor('#0a0a1a');
                }
            }

            // Refresh cylinder layout to update ring opacities
            if (currentLayout === 'cylinder' && ringsEnabled) {
                clearTierPlatforms();
                applyCylinderLayout();
            }
        }

        // --- Rings toggle (for cylinder layout) ---
        function toggleRings() {
            ringsEnabled = !ringsEnabled;
            document.getElementById('rings-toggle').classList.toggle('active', ringsEnabled);

            if (currentLayout === 'cylinder') {
                if (ringsEnabled) {
                    clearTierPlatforms();
                    applyCylinderLayout();
                } else {
                    clearTierPlatforms();
                }
            }
        }

        // --- Unified node rendering ---
        function rebuildNodeRendering() {
            if (logoLabelsEnabled) {
                // Logo+Label sprite mode (matches Zeus decision graph style)
                graph.nodeThreeObject(node => {
                    const size = Math.max((node.val || 10) / 5, 3) * 2;
                    const color = multiSelectedNodes.has(node.id) ? '#ffd700' : (node.color || '#718096');
                    return createLogoLabelSprite(node.name, color, size, node.type, node.logo);
                });
                graph.nodeThreeObjectExtend(false);
            } else {
                // 3D geometry mode
                graph.nodeThreeObjectExtend(true);
                graph.nodeThreeObject(node => {
                    const group = new THREE.Group();
                    const size = (node.val || 10) / 6;

                    let geometry;
                    switch(currentGeometry) {
                        case 'cube':
                            geometry = new THREE.BoxGeometry(size, size, size);
                            break;
                        case 'diamond':
                            geometry = new THREE.OctahedronGeometry(size);
                            break;
                        case 'ring':
                            geometry = new THREE.TorusGeometry(size * 0.7, size * 0.2, 8, 24);
                            break;
                        default: // sphere - use type-based shapes
                            switch(node.type) {
                                case 'hub':
                                    geometry = new THREE.IcosahedronGeometry(size * 1.5);
                                    break;
                                case 'tenant':
                                    geometry = new THREE.OctahedronGeometry(size * 1.2);
                                    break;
                                case 'source':
                                    geometry = new THREE.BoxGeometry(size, size, size);
                                    break;
                                default:
                                    geometry = new THREE.SphereGeometry(size * 0.7, 16, 16);
                            }
                    }

                    const material = new THREE.MeshPhongMaterial({
                        color: multiSelectedNodes.has(node.id) ? '#ffd700' : (node.color || '#718096'),
                        transparent: true,
                        opacity: 0.9,
                        shininess: 80
                    });

                    const mesh = new THREE.Mesh(geometry, material);
                    group.add(mesh);

                    // Glow effect
                    if (glowEnabled || node.type === 'hub' || node.type === 'tenant') {
                        if (glowEnabled) {
                            const glowTexture = createGlowTexture(node.color || '#718096');
                            const spriteMaterial = new THREE.SpriteMaterial({
                                map: glowTexture,
                                transparent: true,
                                blending: THREE.AdditiveBlending,
                                opacity: 0.5
                            });
                            const sprite = new THREE.Sprite(spriteMaterial);
                            sprite.scale.set(size * 6, size * 6, 1);
                            group.add(sprite);
                        } else {
                            // Default subtle glow for hub/tenant only
                            const glowGeometry = new THREE.SphereGeometry(size * 1.8, 16, 16);
                            const glowMaterial = new THREE.MeshBasicMaterial({
                                color: node.color || '#718096',
                                transparent: true,
                                opacity: 0.12
                            });
                            group.add(new THREE.Mesh(glowGeometry, glowMaterial));
                        }
                    }

                    // Labels for hub and tenants
                    if (labelsEnabled && (node.type === 'hub' || node.type === 'tenant')) {
                        const canvas = document.createElement('canvas');
                        const ctx = canvas.getContext('2d');
                        canvas.width = 256;
                        canvas.height = 64;
                        ctx.font = 'bold 20px Arial';
                        ctx.textAlign = 'center';
                        ctx.fillStyle = 'white';
                        ctx.fillText(node.name.substring(0, 25), 128, 40);

                        const texture = new THREE.CanvasTexture(canvas);
                        const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
                        const sprite = new THREE.Sprite(spriteMaterial);
                        sprite.scale.set(45, 11, 1);
                        sprite.position.y = size * 2 + 8;
                        group.add(sprite);
                    }

                    return group;
                });
            }
        }

        // --- Search ---
        function handleSearch(event) {
            const query = document.getElementById('search-input').value.toLowerCase().trim();
            const resultsEl = document.getElementById('search-results');

            if (!query) {
                resultsEl.classList.remove('active');
                return;
            }

            const matches = graphData.nodes.filter(n =>
                n.name.toLowerCase().includes(query)
            ).slice(0, 10);

            if (matches.length > 0) {
                resultsEl.innerHTML = matches.map(node =>
                    '<div class="search-result-item" onmousedown="searchSelectNode(\'' + node.id + '\')">' +
                    '<div class="name">' + node.name + '</div>' +
                    '<div class="type">' + (node.type || 'node') + '</div>' +
                    '</div>'
                ).join('');
                resultsEl.classList.add('active');
            } else {
                resultsEl.innerHTML = '<div class="search-result-item"><div class="name" style="color:#999">No results</div></div>';
                resultsEl.classList.add('active');
            }

            // Enter key navigates to first result
            if (event.key === 'Enter' && matches.length > 0) {
                searchSelectNode(matches[0].id);
            }
        }

        function showSearchResults() {
            const query = document.getElementById('search-input').value.trim();
            if (query) {
                document.getElementById('search-results').classList.add('active');
            }
        }

        function hideSearchResults() {
            setTimeout(() => {
                document.getElementById('search-results').classList.remove('active');
            }, 200);
        }

        function searchSelectNode(nodeId) {
            document.getElementById('search-input').value = '';
            document.getElementById('search-results').classList.remove('active');
            focusNode(nodeId);
        }

        // --- Multi-select with shift-click ---
        function setupMultiSelect() {
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Shift') {
                    graph.onNodeClick((node) => {
                        if (multiSelectedNodes.has(node.id)) {
                            multiSelectedNodes.delete(node.id);
                        } else {
                            multiSelectedNodes.add(node.id);
                        }
                        updateMultiSelectDisplay();
                        rebuildNodeRendering();
                    });
                }
            });

            document.addEventListener('keyup', function(e) {
                if (e.key === 'Shift') {
                    graph.onNodeClick(node => handleNodeClick(node));
                }
            });
        }

        function handleNodeClick(node) {
            if (node) {
                showNodeInfo(node);
                const distance = 150;
                const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
                graph.cameraPosition(
                    { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio },
                    node, 1500
                );
            }
        }

        function updateMultiSelectDisplay() {
            const countEl = document.getElementById('selection-count');
            if (multiSelectedNodes.size > 0) {
                countEl.textContent = multiSelectedNodes.size + ' selected';
                countEl.classList.add('active');
            } else {
                countEl.classList.remove('active');
            }
        }

        // --- Time slider ---
        function initTimeSlider() {
            const nodesWithDates = graphData.nodes.filter(n => n.createdAt);
            if (nodesWithDates.length > 0) {
                document.getElementById('time-toolbar').style.display = 'flex';

                const dates = nodesWithDates.map(n => new Date(n.createdAt).getTime()).sort((a, b) => a - b);
                window.timeRange = {
                    min: dates[0],
                    max: dates[dates.length - 1]
                };
            }
        }

        function updateTimeSlider() {
            timeSliderValue = parseInt(document.getElementById('time-slider').value);

            if (!window.timeRange) return;

            const cutoffTime = window.timeRange.min + (timeSliderValue / 100) * (window.timeRange.max - window.timeRange.min);
            const cutoffDate = new Date(cutoffTime);

            document.getElementById('time-display').textContent =
                timeSliderValue === 100 ? 'All time' : cutoffDate.toLocaleDateString();

            // Filter nodes by time (respecting existing filters)
            const filteredNodes = graphData.nodes.filter(node => {
                if (!activeNodeTypes.has(node.type)) return false;
                if (node.type === 'source' && !activeSourceCategories.has(node.group || 'other')) return false;
                if (!node.createdAt) return true;
                return new Date(node.createdAt).getTime() <= cutoffTime;
            });

            const filteredNodeIds = new Set(filteredNodes.map(n => n.id));
            const filteredLinks = graphData.links.filter(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                if (!filteredNodeIds.has(sourceId) || !filteredNodeIds.has(targetId)) return false;
                const edgeType = link.type === 'semantic' ? 'semantic' : 'hierarchy';
                return activeEdgeTypes.has(edgeType);
            });

            graph.graphData({ nodes: filteredNodes, links: filteredLinks });
        }

        function toggleTimePlay() {
            const btn = document.getElementById('play-btn');

            if (timePlayInterval) {
                clearInterval(timePlayInterval);
                timePlayInterval = null;
                btn.innerHTML = '&#9654;';
                btn.classList.remove('playing');
            } else {
                if (timeSliderValue >= 100) {
                    document.getElementById('time-slider').value = 0;
                    timeSliderValue = 0;
                }

                btn.innerHTML = '&#9646;&#9646;';
                btn.classList.add('playing');

                timePlayInterval = setInterval(() => {
                    timeSliderValue += 1;
                    document.getElementById('time-slider').value = timeSliderValue;
                    updateTimeSlider();

                    if (timeSliderValue >= 100) {
                        toggleTimePlay();
                    }
                }, 100);
            }
        }

        // --- VR mode ---
        function checkVRSupport() {
            if (navigator.xr) {
                navigator.xr.isSessionSupported('immersive-vr').then(supported => {
                    document.getElementById('vr-btn').disabled = !supported;
                });
            }
        }

        function enterVR() {
            if (graph.scene && navigator.xr) {
                const renderer = graph.renderer();
                renderer.xr.enabled = true;

                navigator.xr.requestSession('immersive-vr').then(session => {
                    renderer.xr.setSession(session);
                });
            }
        }

        // --- Stats display ---
        function updateStats() {
            const nodes = graph.graphData().nodes;
            const links = graph.graphData().links;
            const statsEl = document.getElementById('stats-display');
            statsEl.textContent = nodes.length + ' nodes \u00b7 ' + links.length + ' edges';
        }

        // --- Heatmap coloring ---
        function applyHeatMapColoring(metric) {
            metric = metric || 'connections';
            let values = {};

            if (metric === 'connections') {
                graphData.nodes.forEach(node => {
                    let count = 0;
                    graphData.links.forEach(link => {
                        const sId = typeof link.source === 'object' ? link.source.id : link.source;
                        const tId = typeof link.target === 'object' ? link.target.id : link.target;
                        if (sId === node.id || tId === node.id) count++;
                    });
                    values[node.id] = count;
                });
            } else if (metric === 'recency') {
                const now = Date.now();
                graphData.nodes.forEach(node => {
                    if (node.createdAt) {
                        const age = now - new Date(node.createdAt).getTime();
                        values[node.id] = 1 - (age / (365 * 24 * 60 * 60 * 1000));
                    } else {
                        values[node.id] = 0;
                    }
                });
            }

            const maxVal = Math.max(...Object.values(values));
            const minVal = Math.min(...Object.values(values));
            const range = maxVal - minVal || 1;

            graph.nodeColor(node => {
                const normalized = (values[node.id] - minVal) / range;
                return interpolateColor(normalized);
            });

            document.getElementById('heatmap-legend').classList.add('active');
        }

        function interpolateColor(t) {
            const colors = [
                [49, 130, 206],
                [56, 161, 105],
                [236, 201, 75],
                [229, 62, 62]
            ];

            const idx = t * (colors.length - 1);
            const lower = Math.floor(idx);
            const upper = Math.min(lower + 1, colors.length - 1);
            const frac = idx - lower;

            const r = Math.round(colors[lower][0] + frac * (colors[upper][0] - colors[lower][0]));
            const g = Math.round(colors[lower][1] + frac * (colors[upper][1] - colors[lower][1]));
            const b = Math.round(colors[lower][2] + frac * (colors[upper][2] - colors[lower][2]));

            return `rgb(${r}, ${g}, ${b})`;
        }

        function resetHeatMap() {
            graph.nodeColor(node => node.color);
            document.getElementById('heatmap-legend').classList.remove('active');
        }

        // --- Path highlighting (find shortest path between multi-selected nodes) ---
        function highlightPath() {
            if (multiSelectedNodes.size !== 2) return;

            const [startId, endId] = Array.from(multiSelectedNodes);
            const path = findShortestPath(startId, endId);

            if (path) {
                const pathSet = new Set(path);
                graph.nodeColor(node => pathSet.has(node.id) ? '#ffd700' : '#333333');
                graph.linkColor(link => {
                    const sId = typeof link.source === 'object' ? link.source.id : link.source;
                    const tId = typeof link.target === 'object' ? link.target.id : link.target;
                    const sIdx = path.indexOf(sId);
                    const tIdx = path.indexOf(tId);
                    if (sIdx >= 0 && tIdx >= 0 && Math.abs(sIdx - tIdx) === 1) {
                        return '#ffd700';
                    }
                    return '#222222';
                });
            }
        }

        function findShortestPath(startId, endId) {
            const visited = new Set();
            const queue = [[startId]];

            // Build adjacency
            const adj = {};
            graphData.links.forEach(link => {
                const sId = typeof link.source === 'object' ? link.source.id : link.source;
                const tId = typeof link.target === 'object' ? link.target.id : link.target;
                if (!adj[sId]) adj[sId] = [];
                if (!adj[tId]) adj[tId] = [];
                adj[sId].push(tId);
                adj[tId].push(sId);
            });

            while (queue.length > 0) {
                const path = queue.shift();
                const nodeId = path[path.length - 1];

                if (nodeId === endId) return path;
                if (visited.has(nodeId)) continue;
                visited.add(nodeId);

                const neighbors = adj[nodeId] || [];
                for (const nId of neighbors) {
                    if (!visited.has(nId)) {
                        queue.push([...path, nId]);
                    }
                }
            }

            return null;
        }

        // Filter functions
        function toggleFilter(type, value, element) {
            let set;
            if (type === 'node') set = activeNodeTypes;
            else if (type === 'source') set = activeSourceCategories;
            else if (type === 'edge') set = activeEdgeTypes;

            if (set.has(value)) {
                set.delete(value);
                element.classList.remove('active');
            } else {
                set.add(value);
                element.classList.add('active');
            }
            applyFilters();
        }

        function toggleAllNodes() {
            const chips = document.querySelectorAll('#node-filters .filter-chip');
            const allActive = activeNodeTypes.size === 4;

            if (allActive) {
                activeNodeTypes.clear();
                chips.forEach(c => c.classList.remove('active'));
            } else {
                ['hub', 'tenant', 'source', 'memory'].forEach(t => activeNodeTypes.add(t));
                chips.forEach(c => c.classList.add('active'));
            }
            applyFilters();
        }

        function toggleAllSources() {
            const chips = document.querySelectorAll('#source-filters .filter-chip');
            const allActive = activeSourceCategories.size === 7;

            if (allActive) {
                activeSourceCategories.clear();
                chips.forEach(c => c.classList.remove('active'));
            } else {
                ['email', 'slack', 'rss', 'research', 'api', 'documents', 'other'].forEach(s => activeSourceCategories.add(s));
                chips.forEach(c => c.classList.add('active'));
            }
            applyFilters();
        }

        function toggleSemanticLinks() {
            const chip = document.querySelector('[data-edge="semantic"]');
            if (activeEdgeTypes.has('semantic')) {
                activeEdgeTypes.delete('semantic');
                chip.classList.remove('active');
            } else {
                activeEdgeTypes.add('semantic');
                chip.classList.add('active');
            }
            applyFilters();
        }

        function applyFilters() {
            const filteredNodes = graphData.nodes.filter(node => {
                // Node type filter
                if (!activeNodeTypes.has(node.type)) return false;
                // Source category filter (only for source nodes)
                if (node.type === 'source' && !activeSourceCategories.has(node.group || 'other')) return false;
                return true;
            });

            const nodeIds = new Set(filteredNodes.map(n => n.id));
            const filteredLinks = graphData.links.filter(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                if (!nodeIds.has(sourceId) || !nodeIds.has(targetId)) return false;
                // Edge type filter
                const edgeType = link.type === 'semantic' ? 'semantic' : 'hierarchy';
                if (!activeEdgeTypes.has(edgeType)) return false;
                return true;
            });

            graph.graphData({ nodes: filteredNodes, links: filteredLinks });
            updateStats();
        }

        // Setup filter chip click handlers
        function setupFilterHandlers() {
            document.querySelectorAll('#node-filters .filter-chip').forEach(chip => {
                chip.addEventListener('click', () => {
                    toggleFilter('node', chip.dataset.group, chip);
                });
            });
            document.querySelectorAll('#source-filters .filter-chip').forEach(chip => {
                chip.addEventListener('click', () => {
                    toggleFilter('source', chip.dataset.source, chip);
                });
            });
            document.querySelectorAll('#edge-filters .filter-chip').forEach(chip => {
                chip.addEventListener('click', () => {
                    toggleFilter('edge', chip.dataset.edge, chip);
                });
            });
        }

        function showNodeInfo(node) {
            selectedNode = node;
            document.getElementById('placeholder').style.display = 'none';
            document.getElementById('node-info').classList.add('active');

            document.getElementById('node-color').style.background = node.color;
            document.getElementById('node-title').textContent = node.name;

            const tierEl = document.getElementById('node-tier');
            tierEl.textContent = node.type.charAt(0).toUpperCase() + node.type.slice(1);
            tierEl.className = 'node-tier tier-' + node.type;

            document.getElementById('node-description').textContent = node.description || 'No description available';

            let metaHtml = '';
            if (node.memoryCount) metaHtml += '<span><span class="label">Memories:</span> ' + node.memoryCount.toLocaleString() + '</span>';
            if (node.parentTenant) metaHtml += '<span><span class="label">Tenant:</span> ' + node.parentTenant + '</span>';
            if (node.parentSource) metaHtml += '<span><span class="label">Source:</span> ' + node.parentSource + '</span>';
            if (node.group && node.type === 'source') metaHtml += '<span><span class="label">Category:</span> ' + (node.groupLabel || node.group) + '</span>';
            if (node.createdAt) metaHtml += '<span><span class="label">Created:</span> ' + new Date(node.createdAt).toLocaleDateString() + '</span>';
            if (node.fullId) metaHtml += '<span><span class="label">ID:</span> ' + node.fullId.substring(0, 12) + '...</span>';
            document.getElementById('node-meta').innerHTML = metaHtml;

            // Find connections
            const connections = [];
            graphData.links.forEach(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;

                if (sourceId === node.id) {
                    const target = nodeMap[targetId];
                    if (target) connections.push({ node: target, relation: link.type === 'semantic' ? 'semantic' : 'child', link });
                } else if (targetId === node.id) {
                    const source = nodeMap[sourceId];
                    if (source) connections.push({ node: source, relation: link.type === 'semantic' ? 'semantic' : 'parent', link });
                }
            });

            const listEl = document.getElementById('connections-list');
            if (connections.length > 0) {
                document.getElementById('connections-section').style.display = 'block';
                listEl.innerHTML = connections.slice(0, 25).map(conn => {
                    const isSemantic = conn.relation === 'semantic';
                    const similarity = conn.link.similarity ? ' (' + (conn.link.similarity * 100).toFixed(0) + '% similar)' : '';
                    return '<li class="connection-item ' + (isSemantic ? 'semantic' : '') + '" onclick="focusNode(\'' + conn.node.id + '\')">' +
                        '<div class="conn-color" style="background:' + conn.node.color + '"></div>' +
                        '<div class="conn-info">' +
                        '<div class="name">' + conn.node.name + '</div>' +
                        '<div class="relation">' + (isSemantic ? '&#8596; Semantic' + similarity : (conn.relation === 'parent' ? '&uarr; Parent' : '&darr; Child')) + '</div>' +
                        '</div></li>';
                }).join('');
            } else {
                document.getElementById('connections-section').style.display = 'none';
            }
        }

        function focusNode(nodeId) {
            const node = nodeMap[nodeId];
            if (node && node.x !== undefined) {
                const distance = 150;
                const distRatio = 1 + distance / Math.hypot(node.x, node.y, node.z);
                graph.cameraPosition(
                    { x: node.x * distRatio, y: node.y * distRatio, z: node.z * distRatio },
                    node, 1500
                );
                showNodeInfo(node);
            }
        }

        async function init() {
            let data;
            try {
                const response = await fetch('/api/tenant-graph');
                if (response.ok) {
                    data = await response.json();
                }
            } catch (e) {
                console.error('Failed to load graph data:', e);
            }

            if (!data || !data.nodes || data.nodes.length === 0) {
                document.getElementById('loading').innerHTML = '<div style="color:#e53e3e;font-size:14px;">Failed to load graph data' + (data && data.error ? ': ' + data.error : '') + '</div>';
                return;
            }

            graphData = data;

            // Build node lookup
            data.nodes.forEach(node => {
                nodeMap[node.id] = node;
            });

            // Update stats
            document.getElementById('total-memories').textContent = data.stats && data.stats.total_memories ? (data.stats.total_memories / 1000000).toFixed(1) + 'M' : '-';
            document.getElementById('total-tenants').textContent = data.stats && data.stats.tenant_count ? data.stats.tenant_count : '-';
            document.getElementById('total-sources').textContent = data.stats && data.stats.source_count ? data.stats.source_count : '-';
            document.getElementById('total-semantic').textContent = data.stats && data.stats.semantic_links ? data.stats.semantic_links : '0';

            // Setup filter handlers
            setupFilterHandlers();

            // Initialize graph
            const container = document.getElementById('graph');

            graph = ForceGraph3D()(container)
                .backgroundColor('#0a0a1a')
                .graphData(graphData)
                .nodeLabel('')
                .nodeVal(node => node.val || 10)
                .nodeColor(node => node.color || '#718096')
                .nodeOpacity(0.9)
                .linkColor(link => link.type === 'semantic' ? 'rgba(183, 148, 244, 0.6)' : 'rgba(99, 179, 237, 0.35)')
                .linkWidth(link => link.type === 'semantic' ? 2 : (link.value || 1))
                .linkOpacity(0.7)
                .linkDirectionalParticles(link => link.type === 'semantic' ? 4 : 2)
                .linkDirectionalParticleWidth(link => link.type === 'semantic' ? 3 : 1.5)
                .linkDirectionalParticleSpeed(0.006)
                .linkDirectionalParticleColor(link => link.type === 'semantic' ? '#b794f4' : '#63b3ed')
                .onNodeHover(node => { container.style.cursor = node ? 'pointer' : 'default'; })
                .onNodeClick(node => handleNodeClick(node));

            // Custom node rendering
            rebuildNodeRendering();

            // Add lighting
            const scene = graph.scene();
            scene.add(new THREE.AmbientLight(0xffffff, 0.6));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(100, 100, 100);
            scene.add(dirLight);

            // Initial camera position
            setTimeout(() => {
                graph.cameraPosition({ x: 0, y: 200, z: 500 }, { x: 0, y: 0, z: 0 }, 0);
            }, 100);

            // Setup multi-select
            setupMultiSelect();

            // Initialize time slider if data has dates
            initTimeSlider();

            // Check VR support
            checkVRSupport();

            // Update stats display
            updateStats();

            document.getElementById('loading').classList.add('hidden');
        }

        // Initialize when DOM is ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }
    </script>
</body>
</html>
